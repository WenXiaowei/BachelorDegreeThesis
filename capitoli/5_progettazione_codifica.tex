% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../tesi.tex

%**************************************************************
\chapter{Progettazione e codifica}
\label{ch:progettazione-e-codifica}
%**************************************************************

\intro{In questo capitolo vengono presentate le tecnologie e gli strumenti utilizzati, il ciclo di sviluppo del software adottato e i design pattern utilizzati.}\\

%**************************************************************
\section{Tecnologie e strumenti}
\label{sec:tecnologie-strumenti}

Di seguito viene data una panoramica delle tecnologie e strumenti utilizzati.

\subsection*{CFR - decompilatore java}
CFR è il decompilatore utilizzato per trasformare il codice bytecode \textit{.class} in \textit{.java};
\url{http://www.benf.org/other/cfr/index.html}

\subsection*{Apk Tool}
Apktool è un tool per effettuare il reverse engineering delle applicazioni Android. Può decodificare le risorse contenute nell'APK in una forma quasi uguale a quelli originali, può anche di ricostruire l'APK dopo le modifiche alle risorse modificate.
\url{https://ibotpeaches.github.io/Apktool/}
\subsection*{Dex2Jar}
Questo strumento permette di trasformare i file \textit{.dex} in formato \textit{.jar} in modo che possa essere letta attraverso un software di compressione, come 7Zip, per poter accedere quindi ai file di tipo \textit{.class}.
\url{https://github.com/pxb1988/dex2jar}

\subsection*{Android Emulator}
Lo strumento che permette di avviare degli emulatori Android, conosciuti anche come AVD. \`{E} stato utilizzato per eseguire l'applicazione ricompilata, per poter fare il dump dei dati presenti nell'area di storage dell'applicazione, come i file JSON, XML e SQLite, o come il file delle attività di rete.

\subsection*{Intellij IDEA}
L'IDE utilizzato per la scrittura del codice in Java.

\subsection*{Maven}
\subsection*{Astah}

\subsection*{Java}
\subsection*{Json}
\subsection*{Git - GitLab}


%**************************************************************
\section{Ciclo di vita del software}
\label{sec:ciclo-vita-software}

%**************************************************************
\section{Progettazione}
\label{sec:progettazione}

\subsection{Package}\label{subsec:package}
Questo è il root package del tool, contiene altri package e le due classi elencati successivamente.
\begin{namespacedesc}
    \classdesc{ApatLauncher}{\`{E} la classe di launcher del tool, si occupa principalmente di mettere in relazione di observed-observer i componenti della vista con i dati del modello;}
    \classdesc{Utils}{La classe di utilities che ha delle funzioni statiche utilizzata nel tool per evitare la ripetizione del codice.}
\end{namespacedesc}

\subsubsection{Package it.imolinfo.apat.controller} %**************************
Questo è il package che contiene la classe Controller e ciò che riguarda l'interazione del controller con il filesystem.
\begin{namespacedesc}
    \classdesc{AndroidManifestEditor.java}{\`{E} la classe che si occupa, dato un oggetto di tipo File Android Manifest, di modificare e/o aggiungere il tag \textit{debugabble} impostando il suo valore a \textit{true};}
    \classdesc{Controller}{\`{E} il controller del MVC, si occupa di effettuare le operazioni di decompilazione, ricompilazione, decodifica e analisi dei file;}
    \classdesc{MVCModule}{\`{E} la classe di effettuare la dependency injection per la creazione del MVC.}
\end{namespacedesc}

\subsubsection{Package it.imolinfo.apat.model} %**************************
Questo package contiene le classi che riguardano il modello del pattern Model View Controller.
\begin{namespacedesc}
    \classdesc{Modello}{La classe che contiene i dati utili al corretto funzionamento del tool;}
    \classdesc{ModelState}{\`{E} la classe che viene usato per poter salvare lo stato del funzionamento del tool. Lo stato viene salvato quando viene chiuso il tool, e viene ricaricato al successivo avvio;}
    \classdesc{PDFWriter}{\`{E} la classe wrapper che si occupa della creazione del file PDF per salvare i risultati dell'analisi;}
    \classdesc{Result}{\`{E} la classe di messaggio che viene restituita quando il tool interagisce con il file system;}
    \classdesc{Unzipper}{\`{E} la classe si occupa di decomprimere i file zip;}
    \classdesc{Dumper}{\`{E} la classe che si occupa di effettuare il dump dei dati da un file con estensione \textit{db};}
\end{namespacedesc}

\subsubsection{Package it.imolinfo.apat.pattern} %**************************
Questo package contiene degli sotto-package ognuno dei quali rappresenta un design pattern utilizzato nello sviluppo del tool.
\begin{namespacedesc}
    \classdesc{analyzer.Analyze}{\`{E} l'interfaccia di base del pattern Decorator.}
    \classdesc{analyzer.BaseAnalyze}{\`{E} la classe dell'oggetto base che viene decorato.}
    \classdesc{analyzer.BaseAnalyzeDecorator}{\`{E} il classe astratta del decorator di base che implementa l'interfaccia Analyze, e ha un metodo astratto \textit{doAnalysis()} che deve essere implementato dai decorator concreti.}
    \classdesc{analyzer.DumpDataBase}{\`{E} il decorator che si occupa di estrarre i contenuti dei file \textit{.db} scaricati dall'area di storage dell'app.}
    \classdesc{analyzer.DumpedFilesAnalyzer}{\`{E} il decorator che si occupa di analizzare i file dell'area di storage dell'applicazione con estensione \textit{XML} e \textit{json}, principalmente, legge il contenuto di tali file, e in base ad una whitelist, seleziona quali risultati restituire al chiamante.}
    \classdesc{analyzer.LambdaCounter}{\`{E} il decorator che conta il numero di lambda presente per ogni classe di codice \textit{.java} decompilato.}
    \classdesc{analyzer.StringFinder}{\`{E} il decorator che analizza i file di tipo \textit{.java}, ed estrae le stringhe hardcoded, può essere utilizzato insieme a un blacklist delle stringhe che devono essere ignorate.}
\end{namespacedesc}
\begin{namespacedesc}
    \classdesc{observer.Observable}{La classe parametrizzata T che può essere osservato;}
    \classdesc{observer.Observer}{L'interfaccia parametrizzata che ha il ruolo dell'observer;}
\end{namespacedesc}
\begin{namespacedesc}
    \classdesc{CliCommandFactory.Commands}{\`{E} l'interfaccia che contiene i metodi, dove ognuno dei quali deve generare delle istruzioni per la linea di comando.}
    \classdesc{CliCommandFactory.CommandFactory}{\`{E} la classe astratta che implementa la precendente interfaccia, con un costruttore di base che richiede un path di base.}
    \classdesc{CliCommandFactory.UnixCommandFactory}{\`{E} l'implementazione della classe astratta CommandFactory per il sistema UNIX.}
    \classdesc{CliCommandFactory.WindowsCommandFactory}{\`{E} l'implementazione della classe astratta CommandFactory per il sistema Windows.}
\end{namespacedesc}

\subsubsection{Package it.imolinfo.apat.view} %**************************
\begin{namespacedesc}
    \classdesc{AnalysisChooser}{\`{E} la finestra che mostra le opzioni di analisi.}
    \classdesc{View}{\`{E} la finestra principale, dove permette di selezionare il file \textit{apk} da decompilare ed analizzare.}
    \classdesc{WaitAction}{\`{E} un'implementazione della classe Action che permette di eseguire un processo mostrando la barra del caricamento.}
    \classdesc{ApkFilter}{\`{E} l'implementazione dell'interfaccia \textbf{FileFilter} che accetta solo i file di tipo \textit{APK}}
    \classdesc{KeyStoreFilter}{\`{E} l'implementazione dell'interfaccia \textbf{FileFilter} che accetta solo i file di tipo \textit{JKS}}
    \classdesc{TextFilter}{\`{E} l'implementazione dell'interfaccia \textbf{FileFilter} che accetta solo i file di tipo \textit{txt}}
\end{namespacedesc}


%**************************************************************
\section{Design Pattern utilizzati}\label{sec:design-pattern-utilizzati}
\subsection{Model View Controller}\label{subsec:model-view-controller}
\subsection{Observer}\label{subsec:observer}
\subsection{Decorator}\label{subsec:decorator}
%**************************************************************
\section{Codifica}\label{sec:codifica}
